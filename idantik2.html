<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Convergence ‚Äî Jeu de formes</title>
  <style>
    :root{--bg:#0f1621;--card:#0b1220;--accent:#7bd389;--muted:#cfd8e3}
    *{box-sizing:border-box;font-family:Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial}
    body{margin:0;background:linear-gradient(180deg,white 0%,grey 100%);color:var(--muted);display:flex;flex-direction:column;align-items:center;min-height:100vh;padding:0 10px}
    header{width:100%;max-width:980px;padding:18px 20px;display:flex;justify-content:space-between;align-items:center}
    h1{margin:0;font-size:18px;color:var(--accent)}
    .controls{display:flex;gap:10px;align-items:center}
    .panel{background:#0b1220;padding:14px;border-radius:12px;box-shadow:0 6px 20px rgba(2,6,23,0.6)}
    #game-area{width:100%;max-width:980px;padding:18px;display:flex;gap:18px;flex-direction:column;align-items:center}
    canvas{background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:10px;display:block}
    .hud{width:100%;display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap}
    .big{font-size:24px;color:#fff;font-weight:700}
    .timer-section{display:flex;align-items:center;gap:10px}
    .timer-bar{height:12px;border-radius:8px;background:rgba(255,255,255,0.06);overflow:hidden;width:200px}
    .timer-fill{height:100%;width:100%;background:linear-gradient(90deg,#7bd389,#4bc0f0);transform-origin:left;transition:width 0.04s linear}
    .buttons{display:flex;gap:12px;flex-direction:column;align-items:center;width:100%}
    .main-buttons{display:flex;gap:12px;width:100%}
    .secondary-buttons{display:flex;gap:8px}
    button.btn{padding:16px 24px;border-radius:10px;border:0;background:#15202b;color:white;font-weight:600;cursor:pointer;font-size:16px;flex:1;min-height:60px}
    button.btn.secondary{padding:10px 16px;font-size:14px;background:#1a2533;min-height:auto;flex:none}
    button.btn:active{transform:translateY(1px)}
    .feedback{height:50px;font-weight:700;font-size:48px;display:flex;align-items:center;justify-content:center}
    .lives{display:flex;gap:6px;font-size:24px}
    .footer{margin-top:8px;font-size:13px;color:#9fb1c9;text-align:center}
    
    /* Mobile optimization */
    @media(max-width:640px){
      body{padding:0 8px}
      header{padding:12px 8px;flex-direction:column;gap:12px;align-items:stretch}
      h1{font-size:16px;text-align:center}
      .controls{flex-direction:column;gap:8px;width:100%}
      .panel{padding:10px 12px}
      #game-area{padding:12px 8px;gap:12px}
      canvas{width:100%!important;height:240px!important}
      .hud{flex-direction:column;gap:12px;align-items:stretch}
      .timer-section{justify-content:space-between;width:100%}
      .timer-bar{flex:1;min-width:120px}
      .big{font-size:20px}
      .feedback{font-size:36px;height:40px}
      button.btn{font-size:18px;min-height:56px;padding:14px 20px}
      button.btn.secondary{font-size:13px;padding:8px 14px}
      .main-buttons{flex-direction:row}
      .footer{font-size:12px;padding:0 8px}
      .lives{font-size:20px}
    }
    
    @media(max-width:400px){
      h1{font-size:14px}
      canvas{height:200px!important}
      button.btn{font-size:16px;min-height:52px}
      .big{font-size:18px}
    }
  </style>
</head>
<body>
  <header>
    <h1>Convergence ‚Äî reconnais la forme</h1>
    <div class="controls">
      <div class="panel">
        <div>Score: <span id="score" class="big">0</span></div>
      </div>
      <div class="panel">
        <div class="lives" id="lives">‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è</div>
      </div>
    </div>
  </header>

  <main id="game-area">
    <div class="hud">
      <div class="feedback" id="feedback">&nbsp;</div>
      <div class="timer-section">
        <div class="timer-bar panel"><div id="timerFill" class="timer-fill" style="width:100%"></div></div>
        <div class="panel"><span id="timeLeft" class="big">3.00s</span></div>
      </div>
    </div>

    <canvas id="board" width="900" height="340" aria-label="Zone de jeu dessinant trois formes"></canvas>

    <div class="buttons">
      <div class="main-buttons">
        <button id="yesBtn" class="btn">OUI</button>
        <button id="noBtn" class="btn">NON</button>
      </div>
      <div class="secondary-buttons">
        <button id="startBtn" class="btn secondary">D√©marrer</button>
        <button id="settingsBtn" class="btn secondary">R√©initialiser</button>
      </div>
    </div>

    <div class="footer">Les couleurs sont purement esth√©tiques ‚Äî seul le type de forme compte.</div>
  </main>

  <script>
  (function(){
    const shapesList = [
      'circle', 'square', 'roundedSquare', 'rectangle', 'roundedRect',
      'triangle', 'diamond', 'pentagon', 'hexagon', 'star', 'ellipse'
    ];

    const colors = [
      '#ef476f','#ffd166','#06d6a0','#118ab2','#073b4c','#8ecae6','#ffb4a2','#a0c4ff','#bdb2ff','#ffc6ff'
    ];
    
    // Groupes de formes similaires pour augmenter la difficult√©
const similarShapes = [
  ['square', 'roundedSquare', 'diamond'],
  ['rectangle', 'roundedRect'],
  ['circle', 'ellipse'],
  ['pentagon', 'hexagon']
];


    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const yesBtn = document.getElementById('yesBtn');
    const noBtn = document.getElementById('noBtn');
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('settingsBtn');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const feedbackEl = document.getElementById('feedback');
    const timerFill = document.getElementById('timerFill');
    const timeLeftEl = document.getElementById('timeLeft');

    let timeLimit = 3.0;
    let timer = null;
    let endTime = 0;
    let current = null;
    let score = 0;
    let lives = 3;
    let running = false;

    function resizeCanvas(){
      const ratio = window.devicePixelRatio || 1;
      const maxWidth = Math.min(980, window.innerWidth - 40);
      const width = maxWidth;
      const isMobile = window.innerWidth <= 640;
      const height = isMobile ? 240 : 340;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      canvas.width = Math.floor(width * ratio);
      canvas.height = Math.floor(height * ratio);
      ctx.setTransform(ratio,0,0,ratio,0,0);
      renderCurrent();
    }
    window.addEventListener('resize', resizeCanvas);

    function randInt(max){ return Math.floor(Math.random()*max); }
    function choose(arr){ return arr[randInt(arr.length)]; }
    
    function genRound(){
  const converge = Math.random() < 0.5;
  const useSimilar = Math.random() < 0.5; // 50% chance d'utiliser des formes similaires
  let shapes = [];
  
  if(converge){
    const s = choose(shapesList);
    shapes = [s,s,s];
  } else {
    if(useSimilar && similarShapes.length > 0){
      // Choisir un groupe de formes similaires
      const group = choose(similarShapes);
      // S'assurer qu'on a au moins 2 formes diff√©rentes du groupe
      if(group.length >= 2){
        const shape1 = choose(group);
        let shape2 = choose(group);
        while(shape2 === shape1 && group.length > 1){
          shape2 = choose(group);
        }
        const shape3 = choose(group);
        shapes = [shape1, shape2, shape3];
      } else {
        // Fallback si le groupe n'a qu'une forme
        while(true){
          shapes = [choose(shapesList), choose(shapesList), choose(shapesList)];
          if(!(shapes[0]===shapes[1] && shapes[1]===shapes[2])) break;
        }
      }
    } else {
      // G√©n√©ration normale (formes al√©atoires)
      while(true){
        shapes = [choose(shapesList), choose(shapesList), choose(shapesList)];
        if(!(shapes[0]===shapes[1] && shapes[1]===shapes[2])) break;
      }
    }
  }
  
  const cols = [choose(colors), choose(colors), choose(colors)];
  return {shapes:shapes, colors:cols, convergent: (shapes[0]===shapes[1]&&shapes[1]===shapes[2])};
}


    function drawShape(type, color, cx, cy, size){
      ctx.save();
      ctx.translate(cx,cy);
      ctx.fillStyle = color;
      ctx.strokeStyle = '#ffffff22';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      switch(type){
        case 'circle':
          ctx.arc(0,0,size*0.45,0,Math.PI*2); ctx.fill(); break;
        case 'ellipse':
          ctx.ellipse(0,0,size*0.5,size*0.33,0,0,Math.PI*2); ctx.fill(); break;
        case 'square':
          ctx.fillRect(-size*0.4,-size*0.4,size*0.8,size*0.8); break;
        case 'roundedSquare':
          roundRect(ctx,-size*0.4,-size*0.4,size*0.8,size*0.8, size*0.12); ctx.fill(); break;
        case 'rectangle':
          ctx.fillRect(-size*0.45,-size*0.32,size*0.9,size*0.64); break;
        case 'roundedRect':
          roundRect(ctx,-size*0.45,-size*0.32,size*0.9,size*0.64, size*0.08); ctx.fill(); break;
        case 'triangle':
          ctx.moveTo(0,-size*0.45); ctx.lineTo(size*0.42,size*0.35); ctx.lineTo(-size*0.42,size*0.35); ctx.closePath(); ctx.fill(); break;
        case 'diamond':
          ctx.rotate(Math.PI/4); ctx.fillRect(-size*0.36,-size*0.36,size*0.72,size*0.72); break;
        case 'pentagon':
          regularPoly(ctx,5,size*0.43); ctx.fill(); break;
        case 'hexagon':
          regularPoly(ctx,6,size*0.42); ctx.fill(); break;
        case 'star':
          star(ctx,5,size*0.45,size*0.2); ctx.fill(); break;
        default:
          ctx.fillRect(-size*0.4,-size*0.4,size*0.8,size*0.8);
      }
      ctx.stroke();
      ctx.restore();
    }

    function roundRect(ctx,x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    function regularPoly(ctx,n,r){
      const ang = Math.PI*2/n;
      ctx.beginPath();
      for(let i=0;i<n;i++){
        const a = -Math.PI/2 + i*ang;
        const x = Math.cos(a)*r; const y = Math.sin(a)*r;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
    }

    function star(ctx,points,outer,inner){
      ctx.beginPath();
      const step = Math.PI/points;
      for(let i=0;i<2*points;i++){
        const r = (i%2===0)?outer:inner;
        const a = -Math.PI/2 + i*step;
        const x = Math.cos(a)*r; const y = Math.sin(a)*r;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
    }

    function renderCurrent(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const w = parseFloat(canvas.style.width);
      const h = parseFloat(canvas.style.height);
      const margin = 30;
      const zoneW = (w - margin*2) / 3;
      const cxList = [margin + zoneW/2, margin + zoneW/2 + zoneW, margin + zoneW/2 + 2*zoneW];
      const cy = h/2;
      const size = Math.min(zoneW*0.9, h*0.8)/1.6;

      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      for(let i=0;i<3;i++){
        const x = margin + i*zoneW;
        ctx.fillRect(x + 8, (h- (size*1.5))/2 + 8, zoneW - 16, size*1.5);
      }

      if(!current) return;
      for(let i=0;i<3;i++){
        drawShape(current.shapes[i], current.colors[i], cxList[i], cy, size);
      }
    }

    function updateLives(){
      const hearts = ['‚ù§Ô∏è', '‚ù§Ô∏è', '‚ù§Ô∏è'];
      for(let i = 0; i < 3; i++){
        if(i >= lives) hearts[i] = 'üñ§';
      }
      livesEl.innerHTML = hearts.join(' ');
    }

    function startTimer(){
      clearInterval(timer);
      endTime = performance.now() + timeLimit*1000;
      timer = setInterval(()=>{
        const now = performance.now();
        const left = Math.max(0, (endTime - now)/1000);
        const pct = Math.max(0, left / timeLimit);
        timerFill.style.width = (pct*100) + '%';
        timeLeftEl.textContent = left.toFixed(2) + 's';
        if(left <= 0){ clearInterval(timer); onTimeout(); }
      }, 40);
    }

    function stopTimer(){ clearInterval(timer); timer = null; }

    function onTimeout(){
      feedback('‚è∞', 'bad');
      running = false;
      lives--;
      updateLives();
      if(lives <= 0){
        endGame();
      } else {
        setTimeout(nextRound, 800);
      }
    }

    function feedback(txt,state){
      feedbackEl.textContent = txt;
      feedbackEl.style.color = (state==='good')? '#7bd389' : (state==='bad')? '#ff6b6b' : '#ffd166';
      setTimeout(()=>{ if(running || lives <= 0) feedbackEl.textContent=''; }, 800);
    }

    function handleAnswer(ans){
      if(!running) return;
      stopTimer();
      running = false;
      const correct = current.convergent ? (ans === 'yes') : (ans === 'no');
      if(correct){ 
        score += 1; 
        feedback('‚úì', 'good'); 
        scoreEl.textContent = score;
        setTimeout(nextRound, 600);
      }
      else { 
        feedback('‚úó', 'bad'); 
        lives--;
        updateLives();
        if(lives <= 0){
          setTimeout(endGame, 800);
        } else {
          setTimeout(nextRound, 800);
        }
      }
    }

    function endGame(){
      feedback('Game Over ‚Äî Score: ' + score, 'neutral');
      running = false;
      stopTimer();
    }

    function nextRound(){
      if(lives <= 0) return;
      current = genRound();
      renderCurrent();
      running = true;
      startTimer();
      feedbackEl.textContent = '';
    }

    function startGame(){
      score = 0; 
      lives = 3;
      scoreEl.textContent = score; 
      updateLives();
      feedbackEl.textContent='';
      nextRound();
    }

    window.addEventListener('keydown', (e)=>{
      if(e.key === '1' || e.key.toLowerCase()==='o' || e.key.toLowerCase()==='y') handleAnswer('yes');
      if(e.key === '2' || e.key.toLowerCase()==='n') handleAnswer('no');
      if(e.key === ' '){ if(!running && lives > 0) startGame(); }
    });

    yesBtn.addEventListener('click', ()=>handleAnswer('yes'));
    noBtn.addEventListener('click', ()=>handleAnswer('no'));
    startBtn.addEventListener('click', ()=>startGame());
    resetBtn.addEventListener('click', ()=>{ 
      score=0; 
      lives=3; 
      scoreEl.textContent=0; 
      updateLives();
      feedbackEl.textContent=''; 
      stopTimer(); 
      current=null; 
      renderCurrent(); 
    });

    resizeCanvas();
    updateLives();
    current = genRound(); 
    renderCurrent();

  })();
  </script>
</body>
</html>