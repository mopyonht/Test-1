<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>üß© Puzzle - Tournoi</title>
  <style>
    :root{--size:600px;--cells:15}
    body{font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#f3f4f6; color:#111; display:flex; gap:24px; padding:20px; align-items:flex-start; flex-direction:column}
    
    .tournament-info-bar{width:100%;max-width:1200px;background:#fff;border-radius:8px;padding:15px;box-shadow:0 2px 8px rgba(0,0,0,0.1);margin-bottom:15px}
    .tournament-info-bar h3{margin:0 0 10px 0;font-size:16px;color:#333}
    .tournament-stats{display:flex;gap:20px;flex-wrap:wrap;font-size:14px}
    .tournament-stats .stat{display:flex;flex-direction:column}
    .tournament-stats .stat-label{color:#666;font-size:12px}
    .tournament-stats .stat-value{font-weight:700;color:#059669;font-size:16px}
    
    .container{display:flex; flex-direction: column; gap:20px; width:100%; max-width:1200px}
    .bottom-section{display:flex; gap:20px; align-items:flex-start}
    .board-wrap{background:white;padding:24px;border-radius:12px;box-shadow:0 6px 18px rgba(12,12,14,0.08)}
    .board-wrap button {padding: 12px 16px; font-size: 1rem; border-radius: 10px;}
    canvas{display:block; background:linear-gradient(180deg,#ffffff,#fbfdff); border-radius:8px}
    .info{max-width:200px; font-size : 40px; }
    h1{font-size:40px;margin:0 0 8px}
    p.small{margin:6px 0;color:#444}
    .controls{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap}
    button{padding:16px 24px;border-radius:8px;border:0;background:#0ea5a4;color:white;cursor:pointer}
    button.warn{background:#f97316}
    button.ghost{background:#e6e6e6;color:#111}
    button.abandon{background:#dc2626}
    .stats{margin-top:10px}
    .bad{color:#e11d48}
    .good{color:#059669}
    .hint{font-size:25px;color:#555;margin-top:8px}
    .shape-box{background:#fff;padding:30px;border-radius:8px;display:flex;flex-direction:column;gap:8px;align-items:center}
    .small-canvas{width:160px;height:160px;background:#fff;border-radius:8px; touch-action: none;}
    #board { touch-action: none; -ms-touch-action: none; }
    .board-wrap {margin-bottom: 50px;}
    
    .game-over-modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.8);z-index:10000;align-items:center;justify-content:center}
    .game-over-modal.active{display:flex}
    .game-over-content{background:#fff;border-radius:12px;padding:30px;max-width:400px;width:90%;text-align:center}
    .game-over-content h2{margin:0 0 20px 0;font-size:28px;color:#333}
    .game-over-content .final-score{font-size:48px;font-weight:800;color:#059669;margin:20px 0}
    .game-over-content .stats-note{font-size:14px;color:#666;margin:10px 0}
    .game-over-actions{display:flex;gap:10px;margin-top:20px}
    .game-over-actions .btn{flex:1;padding:15px;font-size:16px;min-height:auto}
    .btn-replay{background:#059669}
    .btn-home{background:#6b7280}
    
    @media (min-width: 768px) {
      body { flex-direction: column; align-items: center; padding:50px }
      .container { flex-direction: row; align-items: flex-start; max-width: none; }
      .info { max-width: 300px; min-width: 250px; }
    }
    
    @media (max-width: 480px) {
  body { padding: 5px; }
  
  .tournament-info-bar { 
    padding: 8px; 
    margin-bottom: 8px; 
  }
  
  .tournament-stats { 
    gap: 8px; 
    font-size: 11px; 
  }
  
  .tournament-stats .stat-label { 
    font-size: 10px; 
  }
  
  .tournament-stats .stat-value { 
    font-size: 13px; 
  }
  
  .board-wrap { 
    padding: 8px; 
    margin-bottom: 15px; 
  }
  
  h1 { 
    font-size: 20px; 
    margin-bottom: 4px; 
  }
  
  .controls { 
    flex-direction: column; 
    gap: 6px;
    width: 100%;
    margin-top: 8px;
  }
  
  button { 
    padding: 10px 14px; 
    font-size: 13px;
    width: 100%;
  }
  
  .shape-box { 
    padding: 12px; 
    margin-top: 8px;
  }
  
  .shape-box strong {
    font-size: 14px;
  }
  
  .small-canvas { 
    width: 80px; 
    height: 80px; 
  }
  
  .bottom-section { 
    flex-direction: column; 
    width: 100%;
    gap: 8px;
  }
  
  .stats { 
    font-size: 13px;
    width: 100%;
  }
  
  .info { 
    display: none; 
  }
  
  #shapeColor {
    font-size: 13px;
  }
}
  </style>
</head>
<body>
  <div class="tournament-info-bar">
    <h3 id="tournamentName">Chargement...</h3>
    <div class="tournament-stats">
      <div class="stat">
        <span class="stat-label">üí∞ Prize Pool</span>
        <span class="stat-value" id="prizePool">--</span>
      </div>
      <div class="stat">
        <span class="stat-label">üë• Patisipan</span>
        <span class="stat-value" id="participantCount">--</span>
      </div>
      <div class="stat">
        <span class="stat-label">‚è≥ Tan Ki Rete</span>
        <span class="stat-value" id="timeRemaining">--:--:--</span>
      </div>
      <div class="stat">
        <span class="stat-label">üéÆ Ou Pati</span>
        <span class="stat-value" id="myGamesPlayed">--</span>
      </div>
      <div class="stat">
        <span class="stat-label">üèÜ Ou Mey√® Skor</span>
        <span class="stat-value" id="myBestScore">--</span>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="board-wrap">
      <h1>üß© Grand carr√© ‚Äî Tournoi</h1>
      <div style="text-align:left; margin:-5px 0 5px 0; font-size:13px;">
        Score: <span id="scoreDisplay">1200000</span>
      </div>
      <canvas id="board" width="1500" height="1500"></canvas>
      <div class="controls">
        <button id="passBtn">Refuser</button>
        <button id="restartBtn" class="ghost">Recommencer</button>
        <button id="hintBtn" class="ghost">V√©rifier placements valides</button>
        <button id="rotateBtn" class="ghost">Rotation (<span id="rotations">3</span> restantes)</button>
        <button id="abandonBtn" class="abandon">Abandone</button>
      </div>
      <div class="shape-box" style="margin-top:10px">
        <strong>Forme actuelle</strong>
        <canvas id="shapePreview" class="small-canvas" width="120" height="120"></canvas>
        <div id="shapeColor">Couleur: <span id="colorText">‚Äî</span></div>
      </div>
    </div>

    <div class="bottom-section">
      <div class="info"></div>

      <div class="stats">
        <div>Grille: <strong>15 √ó 15</strong></div>
        <div>Passes totales autoris√©es: <strong>10</strong></div>
        <div>Passes restantes : <span id="passes">10</span></div>
        <div>Occup√©: <span id="filled">0</span>/225</div>
        <div id="message" style="margin-top:8px"></div>
      </div>
    </div>
  </div>

  <div id="gameOverModal" class="game-over-modal">
    <div class="game-over-content">
      <h2>üéÆ Pati Fini!</h2>
      <div class="final-score" id="finalScore">0</div>
      <div class="stats-note">üèÜ Skor final ou</div>
      <div class="stats-note" style="color:#666;font-size:12px;margin-top:15px">
        ‚ö†Ô∏è Skor pi wo ap genyen!
      </div>
      <div class="game-over-actions">
        <button id="replayBtn" class="btn btn-replay">üîÑ Rejwe</button>
        <button id="homeBtn" class="btn btn-home">üè† Ak√®y</button>
      </div>
    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
  
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyDpylenTapoLXwbMsEavlLt0po5M_bVDBo",
      authDomain: "mopyonsiteweb.firebaseapp.com",
      projectId: "mopyonsiteweb",
      storageBucket: "mopyonsiteweb.firebasestorage.app",
      messagingSenderId: "535172052074",
      appId: "1:535172052074:web:c30cefea18ffed7a27c613"
    };

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
  </script>

  <script>
  (function(){
    const tournamentInfo = JSON.parse(localStorage.getItem('currentTournament') || '{}');
    if (!tournamentInfo.tournamentId) {
      alert("Er√®: Pa gen enf√≤masyon sou tounwa a!");
      window.location.href = 'tournaments-home-puzzle.html';
      return;
    }

    const { tournamentId, entryFee, tournamentName } = tournamentInfo;
    let currentUser = null;
    let tournament = null;
    let myParticipantData = null;

    auth.onAuthStateChanged(async (user) => {
      if (user) {
        currentUser = user;
        await loadTournamentData();
      } else {
        window.location.href = 'tournaments-home-puzzle.html';
      }
    });

    async function loadTournamentData() {
      try {
        const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
        if (!tournamentDoc.exists || tournamentDoc.data().status !== 'active') {
          alert("Tounwa sa pa disponib ank√≤!");
          window.location.href = 'tournaments-home-puzzle.html';
          return;
        }
        
        tournament = tournamentDoc.data();
        
        if (tournament.endTime.toDate() < new Date()) {
          alert("Tounwa sa fini deja!");
          window.location.href = 'tournaments-home-puzzle.html';
          return;
        }
        
        const participantDoc = await db.collection('tournaments')
          .doc(tournamentId).collection('participants').doc(currentUser.uid).get();
        
        if (!participantDoc.exists) {
          alert("Ou pa anrejistre nan tounwa sa!");
          window.location.href = 'tournaments-home-puzzle.html';
          return;
        }
        
        myParticipantData = participantDoc.data();
        displayTournamentInfo();
        listenTournamentUpdates();
        
      } catch (error) {
        console.error("Erreur:", error);
        alert("Er√® chajman!");
      }
    }

    function displayTournamentInfo() {
      document.getElementById('tournamentName').textContent = tournament.name;
      document.getElementById('prizePool').textContent = formatGDS(Math.floor(tournament.totalPot * 0.8));
      document.getElementById('participantCount').textContent = tournament.participantCount || 0;
      document.getElementById('myGamesPlayed').textContent = myParticipantData.totalGamesPlayed || 0;
      document.getElementById('myBestScore').textContent = myParticipantData.bestScore || 0;
      startCountdown(tournament.endTime.toDate());
    }

    function startCountdown(endTime) {
      const updateTimer = () => {
        const diff = endTime - new Date();
        const timerEl = document.getElementById('timeRemaining');
        
        if (diff <= 0) {
          timerEl.textContent = 'FINI';
          timerEl.style.color = '#dc2626';
          if (!gameOver) handleGameOver();
          return;
        }
        
        const h = Math.floor(diff / 3600000);
        const m = Math.floor((diff % 3600000) / 60000);
        const s = Math.floor((diff % 60000) / 1000);
        timerEl.textContent = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
      };
      updateTimer();
      setInterval(updateTimer, 1000);
    }

    function listenTournamentUpdates() {
      db.collection('tournaments').doc(tournamentId).onSnapshot(doc => {
        if (!doc.exists) return;
        tournament = doc.data();
        document.getElementById('prizePool').textContent = formatGDS(Math.floor(tournament.totalPot * 0.8));
        document.getElementById('participantCount').textContent = tournament.participantCount || 0;
      });
      
      db.collection('tournaments').doc(tournamentId).collection('participants')
        .doc(currentUser.uid).onSnapshot(doc => {
          if (!doc.exists) return;
          myParticipantData = doc.data();
          document.getElementById('myGamesPlayed').textContent = myParticipantData.totalGamesPlayed || 0;
          document.getElementById('myBestScore').textContent = myParticipantData.bestScore || 0;
        });
    }

    async function submitScore(finalScore) {
      try {
        const tournamentDoc = await db.collection('tournaments').doc(tournamentId).get();
        
        if (!tournamentDoc.exists) {
          alert("‚ùå Tounwa sa pa egziste ank√≤!");
          window.location.href = 'tournaments-home-puzzle.html';
          return false;
        }
        
        const tournamentInfo = tournamentDoc.data();
        
        if (tournamentInfo.status !== 'active') {
          alert("‚ùå Tounwa sa te f√®men deja! Skor ou pa ka konte.");
          window.location.href = 'tournaments-home-puzzle.html';
          return false;
        }
        
        if (tournamentInfo.closedAt) {
          alert("‚ùå Admin te f√®men tounwa sa! Skor ou pa ka konte.");
          window.location.href = 'tournaments-home-puzzle.html';
          return false;
        }
        
        if (tournamentInfo.endTime.toDate() < new Date()) {
          alert("‚ùå Tan tounwa fini! Skor ou pa ka konte.");
          window.location.href = 'tournaments-home-puzzle.html';
          return false;
        }
        
        const gameDuration = STARTING_SCORE - finalScore;
        const ratio = 0;
        
        await db.collection('tournaments')
          .doc(tournamentId)
          .collection('scores')
          .add({
            userId: currentUser.uid,
            score: finalScore,
            duration: gameDuration,
            ratio: ratio,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          });
        
        const participantRef = db.collection('tournaments')
          .doc(tournamentId)
          .collection('participants')
          .doc(currentUser.uid);
        
        const participantDoc = await participantRef.get();
        const currentBest = participantDoc.exists ? participantDoc.data().bestScore : 0;
        
        if (finalScore > currentBest) {
          await participantRef.update({
            bestScore: finalScore,
            bestGameDuration: gameDuration,
            totalGamesPlayed: firebase.firestore.FieldValue.increment(1)
          });
        } else {
          await participantRef.update({
            totalGamesPlayed: firebase.firestore.FieldValue.increment(1)
          });
        }
        
        return true;
        
      } catch (error) {
        console.error("Erreur soumission score:", error);
        return false;
      }
    }

    function showGameOverScreen(finalScore) {
      document.getElementById('finalScore').textContent = finalScore.toLocaleString();
      document.getElementById('gameOverModal').classList.add('active');
    }

    async function replayTournament() {
      const tDoc = await db.collection('tournaments').doc(tournamentId).get();
      if (!tDoc.exists || tDoc.data().status !== 'active') {
        alert("Tounwa sa fini!");
        goHome();
        return;
      }
      
      const userDoc = await db.collection('users').doc(currentUser.uid).get();
      const balance = userDoc.data().balance || 0;
      
      if (balance < entryFee) {
        alert(`Ou pa gen ase lajan! ${balance} GDS`);
        goHome();
        return;
      }
      
      await db.collection('users').doc(currentUser.uid).update({
        balance: firebase.firestore.FieldValue.increment(-entryFee)
      });
      
      await db.collection('tournaments').doc(tournamentId).collection('participants')
        .doc(currentUser.uid).update({
          totalPaid: firebase.firestore.FieldValue.increment(entryFee)
        });
      
      await db.collection('tournaments').doc(tournamentId).update({
        totalPot: firebase.firestore.FieldValue.increment(entryFee)
      });
      
      location.reload();
    }

    function goHome() {
      window.location.href = 'tournaments-home-puzzle.html';
    }

    function formatGDS(n) { return n.toLocaleString() + ' GDS'; }

    async function handleGameOver() {
      if(gameOver) return;
      const finalScore = currentScore;
      const success = await submitScore(finalScore);
      if (success) {
        showGameOverScreen(finalScore);
      } else {
        alert("Er√® anrejistreman skor!");
        goHome();
      }
    }

    document.getElementById('abandonBtn').addEventListener('click', async () => {
      if (gameOver || !confirm("Ou vle abandone?")) return;
      goHome();
    });

    document.getElementById('replayBtn').addEventListener('click', replayTournament);
    document.getElementById('homeBtn').addEventListener('click', goHome);

    // ===== JEU PUZZLE =====
    const COLS = 15, ROWS = 15, CELL = 100;
    const MAX_PASSES = Infinity;
    const STARTING_SCORE = 1200000; // 20 minutes en millisecondes

    const SHAPES = [
      {name:'L', blocks:[[0,0],[0,1],[0,2],[1,2]]},
      {name:'Small L', blocks:[[0,0],[1,0],[1,1]]},
      {name:'I3', blocks:[[0,0],[0,1],[0,2]]},
      {name:'Square3', blocks:[[0,0],[1,0],[0,1]]},
      {name:'Z', blocks:[[0,0],[1,0],[1,1],[2,1]]},
      {name:'T', blocks:[[0,1],[1,0],[1,1],[2,1]]},
      {name:'Big square', blocks:[[0,0],[1,0],[0,1],[1,1]]},
      {name:'Step', blocks:[[0,0],[0,1],[1,1]]},
      {name:'Long4', blocks:[[0,0],[0,1],[0,2],[0,3]]},
      {name:'Corner', blocks:[[0,0],[1,0],[2,0],[2,1]]},
    ];

    const COLORS = ['#ef4444','#f59e0b','#10b981','#3b82f6','#8b5cf6','#ec4899','#06b6d4'];

    let board = Array.from({length:ROWS},()=>Array(COLS).fill(null));
    let currentShape = null;
    let passesLeft = MAX_PASSES;
    let filled = 0;
    let gameOver = false;
    let rotationsLeft = 3;
    let currentShapeRotated = false;

    let isDragging = false;
    let dragSource = null;
    let previewCol = -1;
    let previewRow = -1;

    let startTime = 0;
    let currentScore = STARTING_SCORE;
    let scoreInterval = null;

    const boardCanvas = document.getElementById('board');
    const boardCtx = boardCanvas.getContext('2d');
    const preview = document.getElementById('shapePreview');
    const pctx = preview.getContext('2d');
    const passesSpan = document.getElementById('passes');
    const filledSpan = document.getElementById('filled');
    const messageDiv = document.getElementById('message');

    function randChoice(arr){return arr[Math.floor(Math.random()*arr.length)];}

    function rotateShapeBlocks(blocks) {
      const rotated = blocks.map(([x, y]) => [y, -x]);
      const minX = Math.min(...rotated.map(b => b[0]));
      const minY = Math.min(...rotated.map(b => b[1]));
      return rotated.map(([x, y]) => [x - minX, y - minY]);
    }

    function startScoreCountdown() {
      startTime = Date.now();
      currentScore = STARTING_SCORE;
      if(scoreInterval) clearInterval(scoreInterval);
      scoreInterval = setInterval(updateScore, 50);
    }

    function updateScore() {
      const elapsed = Date.now() - startTime;
      currentScore = Math.max(0, STARTING_SCORE - elapsed);
      document.getElementById('scoreDisplay').textContent = Math.floor(currentScore).toLocaleString();
      
      if(currentScore <= 0 && !gameOver) {
        lose();
      }
    }

    function stopScoreCountdown() {
      if(scoreInterval) {
        clearInterval(scoreInterval);
        scoreInterval = null;
      }
    }

    function newShape(){
      const sBase = JSON.parse(JSON.stringify(randChoice(SHAPES)));
      sBase.color = randChoice(COLORS);
      sBase.name = sBase.name || 'shape';
      currentShape = sBase;
      currentShapeRotated = false;
      drawPreview();
      message('');
      checkGameEndConditions();
    }

function drawGrid(){
      boardCtx.clearRect(0,0,boardCanvas.width,boardCanvas.height);
      boardCtx.fillStyle = '#f0f9ff';
      boardCtx.fillRect(0,0,boardCanvas.width,boardCanvas.height);

      boardCtx.lineWidth = 1;
      boardCtx.strokeStyle = '#d1d5db';
      for(let x=0;x<=COLS;x++){
        boardCtx.beginPath();
        boardCtx.moveTo(x*CELL,0);
        boardCtx.lineTo(x*CELL,ROWS*CELL);
        boardCtx.stroke();
      }
      for(let y=0;y<=ROWS;y++){
        boardCtx.beginPath();
        boardCtx.moveTo(0,y*CELL);
        boardCtx.lineTo(COLS*CELL,y*CELL);
        boardCtx.stroke();
      }

      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const val = board[r][c];
          if(val){
            boardCtx.fillStyle = val;
            boardCtx.fillRect(c*CELL+1, r*CELL+1, CELL-2, CELL-2);
          }
        }
      }

      if(isDragging && previewCol >= 0 && previewRow >= 0 && currentShape) {
        let isValid = true;
        for(const b of currentShape.blocks) {
          const c = previewCol + b[0];
          const r = previewRow + b[1];
          if(c < 0 || c >= COLS || r < 0 || r >= ROWS || board[r][c]) {
            isValid = false;
            break;
          }
        }
        boardCtx.globalAlpha = 0.6;
        boardCtx.fillStyle = isValid ? currentShape.color : '#ef4444';
        currentShape.blocks.forEach(b => {
          const c = previewCol + b[0];
          const r = previewRow + b[1];
          if(c >= 0 && c < COLS && r >= 0 && r < ROWS) {
            boardCtx.fillRect(c * CELL + 1, r * CELL + 1, CELL - 2, CELL - 2);
          }
        });
        boardCtx.globalAlpha = 1;
      }
    }

    function drawPreview(){
      pctx.clearRect(0,0,preview.width,preview.height);
      pctx.fillStyle = '#fff'; pctx.fillRect(0,0,preview.width,preview.height);
      if(!currentShape) return;
      const blocks = currentShape.blocks;
      let maxX = 0, maxY = 0;
      blocks.forEach(b=>{ if(b[0]>maxX) maxX=b[0]; if(b[1]>maxY) maxY=b[1]; });
      const cell = Math.floor(Math.min(preview.width/(maxX+2), preview.height/(maxY+2)) );
      const offsetX = Math.floor((preview.width - (maxX+1)*cell)/2);
      const offsetY = Math.floor((preview.height - (maxY+1)*cell)/2);
      pctx.fillStyle = currentShape.color;
      blocks.forEach(b=>{
        const x = offsetX + b[0]*cell;
        const y = offsetY + b[1]*cell;
        pctx.fillRect(x+2,y+2,cell-4,cell-4);
      });
      document.getElementById('colorText').innerText = currentShape.color;
    }

    function placeShapeAt(anchorCol, anchorRow){
      if(gameOver || !currentShape) return false;
      const blocks = currentShape.blocks;
      for(const b of blocks){
        const c = anchorCol + b[0];
        const r = anchorRow + b[1];
        if(c<0 || c>=COLS || r<0 || r>=ROWS) {
          return false;
        }
        if(board[r][c]) {
          return false;
        }
      }
      for(const b of blocks){
        const c = anchorCol + b[0];
        const r = anchorRow + b[1];
        board[r][c] = currentShape.color;
        filled++;
      }
      updateStats();
      drawGrid();
      if(filled === COLS*ROWS){
        win();
        return true;
      }
      newShape();
      return true;
    }

    function updateStats(){
      document.getElementById('rotations').innerText = rotationsLeft;
      passesSpan.innerText = passesLeft;
      filledSpan.innerText = filled;
      document.getElementById('rotateBtn').disabled = (rotationsLeft <= 0);
    }

    function passShape(){
      if(gameOver) return;
      if(passesLeft<=0) { message('Plus de passes disponibles.', true); return; }
      passesLeft--;
      updateStats();
      newShape();
    }

    function restart(){
      board = Array.from({length:ROWS},()=>Array(COLS).fill(null));
      passesLeft = MAX_PASSES; filled = 0; gameOver=false; rotationsLeft = 3; currentShapeRotated = false;
      document.getElementById('rotateBtn').disabled = false;
      updateStats();
      drawGrid();
      newShape();
      startScoreCountdown();
    }

    function message(txt, isBad=false){
      messageDiv.innerText = txt;
      messageDiv.className = isBad? 'bad': 'good';
    }

    async function win(){
      gameOver = true;
      stopScoreCountdown();
      message('Bravo ‚Äî carr√© rempli ! Tu as gagn√© üéâ');
      
      const finalScore = Math.floor(currentScore);
      const success = await submitScore(finalScore);
      if (success) {
        showGameOverScreen(finalScore);
      } else {
        alert("Er√® anrejistreman skor!");
        goHome();
      }
    }

    function lose(){
      gameOver = true;
      stopScoreCountdown();
      message('Tan fini ‚Äî ou pa gen tan ank√≤!', true);
    }

    function hasValidPlacement(shape){
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          let ok=true;
          for(const b of shape.blocks){
            const cc = c + b[0]; const rr = r + b[1];
            if(cc<0||cc>=COLS||rr<0||rr>=ROWS||board[rr][cc]){ ok=false; break; }
          }
          if(ok) return true;
        }
      }
      return false;
    }

    function checkGameEndConditions(){
      if(!currentShape) return;
      if(!hasValidPlacement(currentShape)){
        if(passesLeft>0){
          message('Aucune position possible pour cette forme ‚Äî tu peux la refuser (pass).', true);
        } else {
          lose();
        }
      }
    }

    function getBoardCoordinatesFromEvent(ev) {
      const rect = boardCanvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      const col = Math.floor(x / CELL);
      const row = Math.floor(y / CELL);
      return {x, y, col, row};
    }

    preview.addEventListener('pointerdown', (e) => {
      if(gameOver || !currentShape) return;
      e.preventDefault();
      isDragging = true;
      dragSource = 'preview';
      preview.setPointerCapture(e.pointerId);
      preview.style.cursor = 'grabbing';
    });

    document.addEventListener('pointermove', (e) => {
      if(!isDragging || !currentShape) return;
      if(dragSource === 'preview' || dragSource === 'board') {
        const rect = boardCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        if(x >= 0 && x < boardCanvas.width && y >= 0 && y < boardCanvas.height) {
          previewCol = Math.floor(x / CELL);
          previewRow = Math.floor(y / CELL);
        } else {
          previewCol = -1;
          previewRow = -1;
        }
        drawGrid();
      }
    });

    document.addEventListener('pointerup', (e) => {
      if(!isDragging || !currentShape) return;
      if(dragSource === 'preview') {
        const rect = boardCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        if(x >= 0 && x < boardCanvas.width && y >= 0 && y < boardCanvas.height) {
          const col = Math.floor(x / CELL);
          const row = Math.floor(y / CELL);
          const ok = placeShapeAt(col, row);
          if(!ok) message('Placement invalide ‚Äî chevauchement ou hors du carr√©.', true);
        }
      } else if(dragSource === 'board') {
        if(previewCol >= 0 && previewRow >= 0) {
          const ok = placeShapeAt(previewCol, previewRow);
          if(!ok) message('Placement invalide ‚Äî chevauchement ou hors du carr√©.', true);
        }
      }
      isDragging = false;
      dragSource = null;
      previewCol = -1;
      previewRow = -1;
      preview.style.cursor = 'default';
      drawGrid();
    });

    boardCanvas.addEventListener('pointerdown', (e) => {
      if(gameOver || !currentShape) return;
      e.preventDefault();
      isDragging = true;
      dragSource = 'board';
      boardCanvas.setPointerCapture(e.pointerId);
      const coords = getBoardCoordinatesFromEvent(e);
      previewCol = coords.col;
      previewRow = coords.row;
      drawGrid();
    });

    boardCanvas.addEventListener('pointerleave', (e) => {
      if(isDragging && dragSource === 'board') {
        isDragging = false;
        dragSource = null;
        previewCol = -1;
        previewRow = -1;
        boardCanvas.style.cursor = 'default';
        drawGrid();
      }
    });

    document.getElementById('hintBtn').addEventListener('click', ()=>{
      if(!currentShape || gameOver) return;
      const positions = [];
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          let ok=true;
          for(const b of currentShape.blocks){
            const cc = c + b[0], rr = r + b[1];
            if(cc<0||cc>=COLS||rr<0||rr>=ROWS||board[rr][cc]){ ok=false; break; }
          }
          if(ok) positions.push([c,r]);
        }
      }
      if(positions.length===0){ message('Aucune position valide pour cette forme.', true); return; }
      let i=0; const interval = setInterval(()=>{
        drawGrid();
        const [c,r] = positions[i%positions.length];
        boardCtx.globalAlpha = 0.45;
        boardCtx.fillStyle = currentShape.color;
        currentShape.blocks.forEach(b=>{
          boardCtx.fillRect((c+b[0])*CELL+1, (r+b[1])*CELL+1, CELL-2, CELL-2);
        });
        boardCtx.globalAlpha = 1;
        i++; if(i>positions.length*2){ clearInterval(interval); drawGrid(); }
      }, 180);
    });

    document.getElementById('passBtn').addEventListener('click', ()=>{ passShape(); });
    document.getElementById('restartBtn').addEventListener('click', ()=>{ restart(); });

    document.getElementById('rotateBtn').addEventListener('click', () => {
      if(!currentShape || gameOver) return;
      if(rotationsLeft <= 0 && !currentShapeRotated) return;
      if(!currentShapeRotated) {
        rotationsLeft--;
        currentShapeRotated = true;
        updateStats();
      }
      currentShape.blocks = rotateShapeBlocks(currentShape.blocks);
      drawPreview();
      checkGameEndConditions();
    });

    restart();

  })();
  </script>
</body>
</html>