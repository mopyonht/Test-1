<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>üß© Tounwa Puzzle d'imbrication</title>
  <style>
    :root{--size:600px;--cells:15}
    body{
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; 
      background:#f3f4f6; 
      color:#111; 
      margin:0;
      padding:0;
      overflow:auto;
      width:100vw;
      height:100vh;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding-top:20px;
    }
    .container{
      display:flex; 
      flex-direction: column; 
      gap:20px;
      max-width:95vw;
      zoom:0.6;
      -moz-transform:scale(0.6);
      -moz-transform-origin:top center;
    }
    .bottom-section{display:flex; gap:20px; align-items:flex-start}
    .board-wrap{
      background:white;
      padding:24px;
      border-radius:12px;
      box-shadow:0 6px 18px rgba(12,12,14,0.08);
      position:relative;
    }

    .board-wrap button {
      padding: 12px 16px;
      font-size: 1rem;
      border-radius: 10px;
    }
    
    canvas{display:block; background:linear-gradient(180deg,#ffffff,#fbfdff); border-radius:8px}
    .info{max-width:200px; font-size : 40px; }
    h1{font-size:40px;margin:0 0 8px}
    p.small{margin:6px 0;color:#444}
    .controls{margin-top:12px;display:flex;gap:8px}
    button{padding:16px 24px;border-radius:8px;border:0;background:#0ea5a4;color:white;cursor:pointer}
    button.warn{background:#f97316}
    button.ghost{background:#e6e6e6;color:#111}
    button:disabled{opacity:0.5;cursor:not-allowed}
    .stats{margin-top:10px}
    .bad{color:#e11d48}
    .good{color:#059669}
    .hint{font-size:25px;color:#555;margin-top:8px}
    .shape-box{background:#fff;padding:30px;border-radius:8px;display:flex;flex-direction:column;gap:8px;align-items:center}
    .small-canvas{width:160px;height:160px;background:#fff;border-radius:8px; touch-action: none;}
   
    #board { touch-action: none; -ms-touch-action: none; }
    
    .board-wrap {
      margin-bottom: 50px;
    }
    
    /* TOURNOI - Affichage du rang et pourcentage */
    .tournament-info{
      position:absolute;
      top:20px;
      right:20px;
      background:rgba(16,185,129,0.95);
      color:white;
      padding:16px 24px;
      border-radius:12px;
      box-shadow:0 4px 16px rgba(16,185,129,0.4);
      z-index:10;
      min-width:200px;
    }
    
    .tournament-info-title{
      font-size:14px;
      opacity:0.9;
      margin-bottom:8px;
    }
    
    .tournament-rank{
      font-size:32px;
      font-weight:900;
      margin-bottom:4px;
    }
    
    .tournament-percentage{
      font-size:24px;
      font-weight:700;
      color:#d1fae5;
    }
    
    .timer-display{
      text-align:left;
      margin:-5px 0 12px 0;
      font-size:28px;
      font-weight:700;
      color:#059669;
    }
    
    @media (min-width: 768px) {
      body { flex-direction: row; align-items: flex-start; }
      .container { flex-direction: row; align-items: flex-start; max-width: none; }
      .info { max-width: 300px; min-width: 250px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="board-wrap">
      <h1>üß© Tounwa Puzzle d'imbrication</h1>
      
      <!-- TOURNOI - Info du tournoi -->
      <div class="tournament-info" id="tournamentInfo">
        <div class="tournament-info-title">Ou pozisyon</div>
        <div class="tournament-rank" id="playerRank">--</div>
        <div class="tournament-percentage" id="playerPercentage">0.00%</div>
      </div>
      
      <div class="timer-display">
        ‚è±Ô∏è <span id="timer">00:00</span>
      </div>
      
      <canvas id="board" width="1500" height="1500"></canvas>
      <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
        <button id="passBtn">Refuser</button>
        <button id="hintBtn" class="ghost">V√©rifier placements</button>
        <button id="rotateBtn" class="ghost">Rotation (<span id="rotations">‚àû</span> restantes)</button>
      </div>
      <div class="shape-box" style="margin-top:10px">
        <strong>Forme actuelle</strong>
        <canvas id="shapePreview" class="small-canvas" width="120" height="120"></canvas>
        <div id="shapeColor">Couleur: <span id="colorText">‚Äî</span></div>
      </div>
    </div>

    <div class="bottom-section">
      <div class="info"></div>

      <div class="stats">
        <div>Grille: <strong>15 √ó 15</strong></div>
        <div>Passes totales autoris√©es: <strong>‚àû</strong></div>
        <div>Passes restantes : <span id="passes">‚àû</span></div>
        <div>Occup√©: <span id="filled">0</span>/225</div>
        <div id="message" style="margin-top:8px"></div>
      </div>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
  
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyDpylenTapoLXwbMsEavlLt0po5M_bVDBo",
      authDomain: "mopyonsiteweb.firebaseapp.com",
      databaseURL: "https://mopyonsiteweb-default-rtdb.firebaseio.com/",
      projectId: "mopyonsiteweb",
      storageBucket: "mopyonsiteweb.firebasestorage.app",
      messagingSenderId: "535172052074",
      appId: "1:535172052074:web:c30cefea18ffed7a27c613"
    };

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const rtdb = firebase.database();
  </script>
  
  <script src="firebaseTournaments-puzzle.js"></script>

<script>
// R√©cup√©rer les infos du tournoi
const tournamentInfo = JSON.parse(localStorage.getItem('currentTournament') || '{}');
if (!tournamentInfo.tournamentId) {
  alert("Er√®: Pa gen enf√≤masyon sou tounwa a!");
  window.location.href = 'tournaments-home-puzzle.html';
}

const COLS = 15, ROWS = 15, CELL = 100;
const MAX_PASSES = Infinity;

const SHAPES = [
  {name:'L', blocks:[[0,0],[0,1],[0,2],[1,2]]},
  {name:'Small L', blocks:[[0,0],[1,0],[1,1]]},
  {name:'I3', blocks:[[0,0],[0,1],[0,2]]},
  {name:'Square3', blocks:[[0,0],[1,0],[0,1]]},
  {name:'Z', blocks:[[0,0],[1,0],[1,1],[2,1]]},
  {name:'T', blocks:[[0,1],[1,0],[1,1],[2,1]]},
  {name:'Big square', blocks:[[0,0],[1,0],[0,1],[1,1]]},
  {name:'Step', blocks:[[0,0],[0,1],[1,1]]},
  {name:'Long4', blocks:[[0,0],[0,1],[0,2],[0,3]]},
  {name:'Corner', blocks:[[0,0],[1,0],[2,0],[2,1]]},
];

const COLORS = ['#ef4444','#f59e0b','#10b981','#3b82f6','#8b5cf6','#ec4899','#06b6d4'];

let board = Array.from({length:ROWS},()=>Array(COLS).fill(null));
let currentShape = null;
let passesLeft = MAX_PASSES;
let filled = 0;
let gameOver = false;
let hasWon = false; // TOURNOI

let isDragging = false;
let dragSource = null;
let previewCol = -1;
let previewRow = -1;

let startTime = 0;
let timerInterval = null;

const boardCanvas = document.getElementById('board');
const boardCtx = boardCanvas.getContext('2d');
const preview = document.getElementById('shapePreview');
const pctx = preview.getContext('2d');
const passesSpan = document.getElementById('passes');
const filledSpan = document.getElementById('filled');
const messageDiv = document.getElementById('message');

// TOURNOI - Initialisation
let totalPlayers = 0;
auth.onAuthStateChanged(async (user) => {
  if (user) {
    const { tournamentId, roomKey } = tournamentInfo;
    
    const playingData = await rtdb.ref(`tournaments/${roomKey}/playing/${tournamentId}/players`).once('value');
    totalPlayers = playingData.val().length;
    
    listenForRankings(tournamentId, roomKey, totalPlayers);
    
    restart();
  }
});

// TOURNOI - Fonction pour mettre √† jour le rang du joueur
window.updatePlayerRank = function(rank, total) {
  document.getElementById('playerRank').textContent = `#${rank} / ${total}`;
};

// TOURNOI - Fonction pour mettre √† jour le pourcentage
function updatePercentageDisplay() {
  const percentage = ((filled / (COLS * ROWS)) * 100).toFixed(2);
  document.getElementById('playerPercentage').textContent = `${percentage}%`;
  
  // Mettre √† jour dans Firebase
  const { tournamentId, roomKey } = tournamentInfo;
  updateProgress(tournamentId, roomKey, parseFloat(percentage));
}

function randChoice(arr){return arr[Math.floor(Math.random()*arr.length)];}

function rotateShapeBlocks(blocks) {
  const rotated = blocks.map(([x, y]) => [y, -x]);
  const minX = Math.min(...rotated.map(b => b[0]));
  const minY = Math.min(...rotated.map(b => b[1]));
  return rotated.map(([x, y]) => [x - minX, y - minY]);
}

function startTimer() {
  startTime = Date.now();
  if(timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(updateTimer, 1000);
}

function updateTimer() {
  const elapsed = Math.floor((Date.now() - startTime) / 1000);
  const minutes = Math.floor(elapsed / 60);
  const seconds = elapsed % 60;
  document.getElementById('timer').innerText =
    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

function stopTimer() {
  if(timerInterval) {
    clearInterval(timerInterval);
    timerInterval = null;
  }
}

function newShape(){
  const sBase = JSON.parse(JSON.stringify(randChoice(SHAPES)));
  sBase.color = randChoice(COLORS);
  sBase.name = sBase.name || 'shape';
  currentShape = sBase;
  drawPreview();
  message('');
  checkGameEndConditions();
}

function drawGrid(){
  boardCtx.clearRect(0,0,boardCanvas.width,boardCanvas.height);
  boardCtx.fillStyle = '#f0f9ff';
  boardCtx.fillRect(0,0,boardCanvas.width,boardCanvas.height);

  boardCtx.lineWidth = 1;
  boardCtx.strokeStyle = '#d1d5db';
  for(let x=0;x<=COLS;x++){
    boardCtx.beginPath();
    boardCtx.moveTo(x*CELL,0);
    boardCtx.lineTo(x*CELL,ROWS*CELL);
    boardCtx.stroke();
  }
  for(let y=0;y<=ROWS;y++){
    boardCtx.beginPath();
    boardCtx.moveTo(0,y*CELL);
    boardCtx.lineTo(COLS*CELL,y*CELL);
    boardCtx.stroke();
  }

  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const val = board[r][c];
      if(val){
        boardCtx.fillStyle = val;
        boardCtx.fillRect(c*CELL+1, r*CELL+1, CELL-2, CELL-2);
      }
    }
  }

  if(isDragging && previewCol >= 0 && previewRow >= 0 && currentShape) {
    let isValid = true;
    for(const b of currentShape.blocks) {
      const c = previewCol + b[0];
      const r = previewRow + b[1];
      if(c < 0 || c >= COLS || r < 0 || r >= ROWS || board[r][c]) {
        isValid = false;
        break;
      }
    }
    boardCtx.globalAlpha = 0.6;
    boardCtx.fillStyle = isValid ? currentShape.color : '#ef4444';
    currentShape.blocks.forEach(b => {
      const c = previewCol + b[0];
      const r = previewRow + b[1];
      if(c >= 0 && c < COLS && r >= 0 && r < ROWS) {
        boardCtx.fillRect(c * CELL + 1, r * CELL + 1, CELL - 2, CELL - 2);
      }
    });
    boardCtx.globalAlpha = 1;
  }
}

function drawPreview(){
  pctx.clearRect(0,0,preview.width,preview.height);
  pctx.fillStyle = '#fff'; pctx.fillRect(0,0,preview.width,preview.height);
  if(!currentShape) return;
  const blocks = currentShape.blocks;
  let maxX = 0, maxY = 0;
  blocks.forEach(b=>{ if(b[0]>maxX) maxX=b[0]; if(b[1]>maxY) maxY=b[1]; });
  const cell = Math.floor(Math.min(preview.width/(maxX+2), preview.height/(maxY+2)) );
  const offsetX = Math.floor((preview.width - (maxX+1)*cell)/2);
  const offsetY = Math.floor((preview.height - (maxY+1)*cell)/2);
  pctx.fillStyle = currentShape.color;
  blocks.forEach(b=>{
    const x = offsetX + b[0]*cell;
    const y = offsetY + b[1]*cell;
    pctx.fillRect(x+2,y+2,cell-4,cell-4);
  });
  document.getElementById('colorText').innerText = currentShape.color;
}

function placeShapeAt(anchorCol, anchorRow){
  if(gameOver || !currentShape || hasWon) return false;
  const blocks = currentShape.blocks;
  for(const b of blocks){
    const c = anchorCol + b[0];
    const r = anchorRow + b[1];
    if(c<0 || c>=COLS || r<0 || r>=ROWS) {
      return false;
    }
    if(board[r][c]) {
      return false;
    }
  }
  for(const b of blocks){
    const c = anchorCol + b[0];
    const r = anchorRow + b[1];
    board[r][c] = currentShape.color;
    filled++;
  }
  updateStats();
  updatePercentageDisplay(); // TOURNOI
  drawGrid();
  if(filled === COLS*ROWS){
    win();
    return true;
  }
  newShape();
  return true;
}

function updateStats(){
  document.getElementById('rotations').innerText = '‚àû';
  passesSpan.innerText = '‚àû';
  filledSpan.innerText = filled;
}

function passShape(){
  if(gameOver || hasWon) return;
  newShape();
}

function restart(){
  board = Array.from({length:ROWS},()=>Array(COLS).fill(null));
  passesLeft = MAX_PASSES; 
  filled = 0; 
  gameOver=false; 
  hasWon=false;
  updateStats();
  updatePercentageDisplay();
  drawGrid();
  newShape();
  startTimer();
}

function message(txt, isBad=false){
  messageDiv.innerText = txt;
  messageDiv.className = isBad? 'bad': 'good';
}

function win(){
  if(hasWon) return;
  hasWon = true;
  gameOver = true;
  stopTimer();
  
  // TOURNOI - Signaler la victoire
  const { tournamentId, roomKey } = tournamentInfo;
  onPlayerWin(tournamentId, roomKey);
}

function hasValidPlacement(shape){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      let ok=true;
      for(const b of shape.blocks){
        const cc = c + b[0]; const rr = r + b[1];
        if(cc<0||cc>=COLS||rr<0||rr>=ROWS||board[rr][cc]){ ok=false; break; }
      }
      if(ok) return true;
    }
  }
  return false;
}

function checkGameEndConditions(){
  if(!currentShape || hasWon) return;
  if(!hasValidPlacement(currentShape)){
    message('Aucune position possible pour cette forme ‚Äî tu peux la refuser (pass).', true);
  }
}

function getBoardCoordinatesFromEvent(ev) {
  const rect = boardCanvas.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  const col = Math.floor(x / CELL);
  const row = Math.floor(y / CELL);
  return {x, y, col, row};
}

preview.addEventListener('pointerdown', (e) => {
  if(gameOver || !currentShape || hasWon) return;
  e.preventDefault();
  isDragging = true;
  dragSource = 'preview';
  preview.setPointerCapture(e.pointerId);
  preview.style.cursor = 'grabbing';
});

document.addEventListener('pointermove', (e) => {
  if(!isDragging || !currentShape) return;
  if(dragSource === 'preview' || dragSource === 'board') {
    const rect = boardCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    if(x >= 0 && x < boardCanvas.width && y >= 0 && y < boardCanvas.height) {
      previewCol = Math.floor(x / CELL);
      previewRow = Math.floor(y / CELL);
    } else {
      previewCol = -1;
      previewRow = -1;
    }
    drawGrid();
  }
});

document.addEventListener('pointerup', (e) => {
  if(!isDragging || !currentShape) return;
  if(dragSource === 'preview') {
    const rect = boardCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    if(x >= 0 && x < boardCanvas.width && y >= 0 && y < boardCanvas.height) {
      const col = Math.floor(x / CELL);
      const row = Math.floor(y / CELL);
      const ok = placeShapeAt(col, row);
      if(!ok) message('Placement invalide ‚Äî chevauchement ou hors du carr√©.', true);
    }
  } else if(dragSource === 'board') {
    if(previewCol >= 0 && previewRow >= 0) {
      const ok = placeShapeAt(previewCol, previewRow);
      if(!ok) message('Placement invalide ‚Äî chevauchement ou hors du carr√©.', true);
    }
  }
  isDragging = false;
  dragSource = null;
  previewCol = -1;
  previewRow = -1;
  preview.style.cursor = 'default';
  drawGrid();
});

boardCanvas.addEventListener('pointerdown', (e) => {
  if(gameOver || !currentShape || hasWon) return;
  e.preventDefault();
  isDragging = true;
  dragSource = 'board';
  boardCanvas.setPointerCapture(e.pointerId);
  const coords = getBoardCoordinatesFromEvent(e);
  previewCol = coords.col;
  previewRow = coords.row;
  drawGrid();
});

boardCanvas.addEventListener('pointerleave', (e) => {
  if(isDragging && dragSource === 'board') {
    isDragging = false;
    dragSource = null;
    previewCol = -1;
    previewRow = -1;
    boardCanvas.style.cursor = 'default';
    drawGrid();
  }
});

document.getElementById('hintBtn').addEventListener('click', ()=>{
  if(!currentShape || gameOver || hasWon) return;
  const positions = [];
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      let ok=true;
      for(const b of currentShape.blocks){
        const cc = c + b[0], rr = r + b[1];
        if(cc<0||cc>=COLS||rr<0||rr>=ROWS||board[rr][cc]){ ok=false; break; }
      }
      if(ok) positions.push([c,r]);
    }
  }
  if(positions.length===0){ message('Aucune position valide pour cette forme.', true); return; }
  let i=0; const interval = setInterval(()=>{
    drawGrid();
    const [c,r] = positions[i%positions.length];
    boardCtx.globalAlpha = 0.45;
    boardCtx.fillStyle = currentShape.color;
    currentShape.blocks.forEach(b=>{
      boardCtx.fillRect((c+b[0])*CELL+1, (r+b[1])*CELL+1, CELL-2, CELL-2);
    });
    boardCtx.globalAlpha = 1;
    i++; if(i>positions.length*2){ clearInterval(interval); drawGrid(); }
  }, 180);
});

document.getElementById('passBtn').addEventListener('click', ()=>{ passShape(); });

// ROTATION INFINIE - Corrig√©
document.getElementById('rotateBtn').addEventListener('click', () => {
  if(!currentShape || gameOver || hasWon) return;
  currentShape.blocks = rotateShapeBlocks(currentShape.blocks);
  drawPreview();
  checkGameEndConditions();
});
</script>
</body>
</html>